(function (factory) {
	typeof define === 'function' && define.amd ? define(factory) :
	factory();
})((function () { 'use strict';

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	/**
	 * Create test stream
	 * @param {string} url
	 * @param {string} description
	 * @param {boolean} [live]
	 * @param {boolean} [abr]
	 * @param {string[]} [skip_ua]
	 * @returns {{url: string, description: string, live: boolean, abr: boolean, skip_ua: string[]}}
	 */
	var testStreams$1;
	var hasRequiredTestStreams;
	function requireTestStreams() {
	  if (hasRequiredTestStreams) return testStreams$1;
	  hasRequiredTestStreams = 1;
	  function createTestStream(url, description, live, abr, skip_ua) {
	    if (live === void 0) {
	      live = false;
	    }
	    if (abr === void 0) {
	      abr = true;
	    }
	    if (skip_ua === void 0) {
	      skip_ua = [];
	    }
	    return {
	      url: url,
	      description: description,
	      live: live,
	      abr: abr,
	      skip_ua: skip_ua
	    };
	  }

	  /**
	   * @param {Object} target
	   * @param {Object} [config]
	   * @returns {{url: string, description: string, live: boolean, abr: boolean, skip_ua: string[]}}
	   */
	  function createTestStreamWithConfig(target, config) {
	    if (typeof target !== 'object') {
	      throw new Error('target should be object');
	    }
	    var testStream = createTestStream(target.url, target.description, target.live, target.abr, target.skip_ua);
	    testStream.config = config;
	    return testStream;
	  }
	  testStreams$1 = {
	    bbb: {
	      url: 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8',
	      description: 'Big Buck Bunny - adaptive qualities',
	      abr: true
	    },
	    fdr: {
	      url: 'https://cdn.jwplayer.com/manifests/pZxWPRg4.m3u8',
	      description: 'FDR - CDN packaged, 4s segments, 180p - 1080p',
	      abr: true
	    },
	    bigBuckBunny480p: {
	      url: 'https://test-streams.mux.dev/x36xhzz/url_6/193039199_mp4_h264_aac_hq_7.m3u8',
	      description: 'Big Buck Bunny - 480p only',
	      abr: false
	    },
	    arte: {
	      url: 'https://test-streams.mux.dev/test_001/stream.m3u8',
	      description: 'ARTE China,ABR',
	      abr: true
	    },
	    deltatreDAI: {
	      url: 'https://test-streams.mux.dev/dai-discontinuity-deltatre/manifest.m3u8',
	      description: 'Ad-insertion in event stream',
	      abr: false
	    },
	    issue666: {
	      url: 'https://playertest.longtailvideo.com/adaptive/issue666/playlists/cisq0gim60007xzvi505emlxx.m3u8',
	      description: 'Surveillance footage - https://github.com/video-dev/hls.js/issues/666',
	      abr: false
	    },
	    closedCaptions: {
	      url: 'https://playertest.longtailvideo.com/adaptive/captions/playlist.m3u8',
	      description: 'CNN special report, with CC',
	      abr: false
	    },
	    customIvBadDts: {
	      url: 'https://playertest.longtailvideo.com/adaptive/customIV/prog_index.m3u8',
	      description: 'Custom IV with bad PTS DTS',
	      abr: false
	    },
	    oceansAES: {
	      url: 'https://playertest.longtailvideo.com/adaptive/oceans_aes/oceans_aes.m3u8',
	      description: 'AES-128 encrypted, ABR',
	      abr: true
	    },
	    tracksWithAES: {
	      url: 'https://playertest.longtailvideo.com/adaptive/aes-with-tracks/master.m3u8',
	      description: 'AES-128 encrypted, TS main with AAC audio track',
	      abr: false
	    },
	    mp3Audio: {
	      url: 'https://playertest.longtailvideo.com/adaptive/vod-with-mp3/manifest.m3u8',
	      description: 'MP3 VOD demo',
	      abr: false
	    },
	    mpegAudioOnly: {
	      url: 'https://pl.streamingvideoprovider.com/mp3-playlist/playlist.m3u8',
	      description: 'MPEG Audio Only demo',
	      abr: false,
	      skip_ua: ['MicrosoftEdge', 'firefox']
	    },
	    fmp4: {
	      url: 'https://storage.googleapis.com/shaka-demo-assets/angel-one-hls/hls.m3u8',
	      description: 'HLS fMP4 Angel-One multiple audio-tracks',
	      abr: true
	    },
	    fmp4Bitmovin: {
	      url: 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s-fmp4/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8',
	      description: 'HLS fMP4 by Bitmovin',
	      abr: true
	    },
	    fmp4BitmovinHevc: {
	      url: 'https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_fmp4.m3u8',
	      description: 'HLS HEVC fMP4 by Bitmovin (Safari and Edge? only as of 2020-08)',
	      abr: true,
	      skipFunctionalTests: true
	    },
	    offset_pts: {
	      url: 'https://test-streams.mux.dev/pts_shift/master.m3u8',
	      description: 'DK Turntable, PTS shifted by 2.3s',
	      abr: true
	    },
	    angelOneShakaWidevine: createTestStreamWithConfig({
	      url: 'https://storage.googleapis.com/shaka-demo-assets/angel-one-widevine-hls/hls.m3u8',
	      description: 'Shaka-packager Widevine DRM (EME) HLS-fMP4 - Angel One Demo',
	      abr: true,
	      skip_ua: ['firefox', 'safari', {
	        name: 'chrome',
	        version: '75.0'
	      }, {
	        name: 'chrome',
	        version: '79.0'
	      }]
	    }, {
	      widevineLicenseUrl: 'https://cwip-shaka-proxy.appspot.com/no_auth',
	      emeEnabled: true
	    }),
	    audioOnlyMultipleLevels: {
	      url: 'https://s3.amazonaws.com/qa.jwplayer.com/~alex/121628/new_master.m3u8',
	      description: 'Multiple non-alternate audio levels',
	      abr: true
	    },
	    pdtDuplicate: {
	      url: 'https://playertest.longtailvideo.com/adaptive/artbeats/manifest.m3u8',
	      description: 'Duplicate sequential PDT values',
	      abr: false
	    },
	    pdtLargeGap: createTestStreamWithConfig({
	      url: 'https://playertest.longtailvideo.com/adaptive/boxee/playlist.m3u8',
	      description: 'PDTs with large gaps following discontinuities',
	      abr: false
	    }, {
	      // gaps are introduced by missing audio samples in the TS segments
	      // silent audio insertion can only prepend missing back to the last appended time provided there is room
	      // The discontinuities and starting offset of the timestamps do not allow prepending earlier than the start of the disco
	      allowedBufferedRangesInSeekTest: 7,
	      // Ignore "should buffer up to maxBufferLength" result
	      avBufferOffset: 39
	    }),
	    pdtBadValues: {
	      url: 'https://playertest.longtailvideo.com/adaptive/progdatime/playlist2.m3u8',
	      description: 'PDTs with bad values',
	      abr: false
	    },
	    pdtOneValue: {
	      url: 'https://playertest.longtailvideo.com/adaptive/aviion/manifest.m3u8',
	      description: 'One PDT, no discontinuities',
	      abr: false
	    },
	    noTrackIntersection: createTestStreamWithConfig({
	      url: 'https://s3.amazonaws.com/qa.jwplayer.com/~alex/123633/new_master.m3u8',
	      description: 'Audio/video track PTS values do not intersect; 10 second start gap',
	      abr: false
	    }, {
	      avBufferOffset: 10.5
	    }),
	    altAudioAndTracks: {
	      // url: 'https://wowzaec2demo.streamlock.net/vod-multitrack/_definst_/smil:ElephantsDream/elephantsdream2.smil/playlist.m3u',
	      url: 'https://playertest.longtailvideo.com/adaptive/elephants_dream_v4/index.m3u8',
	      description: 'Alternate audio tracks, and multiple VTT tracks',
	      vendor: 'wowza',
	      abr: true
	    },
	    altAudioAudioOnly: createTestStreamWithConfig({
	      url: 'https://playertest.longtailvideo.com/adaptive/alt-audio-no-video/sintel/playlist.m3u8',
	      description: 'Audio only with alternate audio track (Sintel)',
	      abr: false
	    }, {
	      // the playlist segment durations are longer than the media. So much so, that when seeking near the end,
	      // the timeline shifts roughly 10 seconds seconds back, and as a result buffering skips several segments
	      // to adjust for the currentTime now being places at the very end of the stream.
	      allowedBufferedRangesInSeekTest: 3
	    }),
	    altAudioMultiAudioOnly: {
	      url: 'https://playertest.longtailvideo.com/adaptive/alt-audio-no-video/angel-one.m3u8',
	      description: 'Audio only with multiple alternate audio tracks (Angel One)',
	      abr: false
	    },
	    muxedFmp4: {
	      url: 'https://s3.amazonaws.com/qa.jwplayer.com/hlsjs/muxed-fmp4/hls.m3u8',
	      description: 'Muxed av fmp4 - appended to "audiovideo" SourceBuffer',
	      abr: false
	    },
	    altAudioWithPdtAndStartGap: {
	      url: 'https://playertest.longtailvideo.com/adaptive/hls-test-streams/test-audio-pdt/playlist.m3u8',
	      description: 'PDT before each segment, 1.59s start gap',
	      // Disable smooth switch on this stream. Test is flakey because of what looks like (auto)play issue. To be expected with this large a gap (for now).
	      // abr: true,
	      startSeek: true
	    },
	    AppleAdvancedHevcAvcHls: {
	      url: 'https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_adv_example_hevc/master.m3u8',
	      description: 'Advanced stream (HEVC/H.264, AC-3/AAC,  WebVTT, fMP4 segments)'
	    },
	    MuxLowLatencyHls: {
	      url: 'https://stream.mux.com/v69RSHhFelSm4701snP22dYz2jICy4E4FUyk02rW4gxRM.m3u8',
	      description: 'Low-Latency HLS sample of Big Buck Bunny loop and a timer. Restarts every 12 hours. (fMP4 segments)',
	      live: true
	    },
	    //   AppleLowLatencyHls: {
	    //     url: 'https://ll-hls-test.apple.com/master.m3u8',
	    //     description: 'Apple Low-Latency HLS sample (TS segments)',
	    //     live: true,
	    //   },
	    //   AppleLowLatencyCmafHls: {
	    //     url: 'https://ll-hls-test.apple.com/cmaf/master.m3u8',
	    //     description: 'Apple Low-Latency HLS sample (fMP4 segments)',
	    //     live: true,
	    //   },
	    groupIds: {
	      url: 'https://mtoczko.github.io/hls-test-streams/test-group/playlist.m3u8',
	      description: 'Group-id: subtitle and audio',
	      abr: true,
	      skipFunctionalTests: true
	    },
	    redundantLevelsWithTrackGroups: {
	      url: 'https://playertest.longtailvideo.com/adaptive/elephants_dream_v4/redundant.m3u8',
	      description: 'Redundant levels with subtitle and audio track groups',
	      abr: true,
	      skipFunctionalTests: true
	    },
	    startDelimiterOverlappingBetweenPESPackets: {
	      url: 'https://wistia.github.io/hlsjs-test-streams/assets/start-delimiter.m3u8',
	      description: "A stream with the start delimiter overlapping between PES packets.\n       Related to https://github.com/video-dev/hls.js/issues/3834, where Apple Silicon chips throw decoding errors if\n       NAL units are not starting right at the beginning of the PES packet when using hardware accelerated decoding.",
	      abr: false,
	      skipFunctionalTests: true
	    },
	    aes256: {
	      url: 'https://jvaryhlstests.blob.core.windows.net/hlstestdata/playlist_encrypted.m3u8',
	      description: 'aes-256 and aes-256-ctr full segment encryption',
	      abr: false
	    },
	    mpegTsHevcHls: {
	      url: 'https://devoldemar.github.io/streams/hls/bipbop/hevc.m3u8',
	      description: 'Advanced stream (HEVC Main 10, MPEG-TS segments)',
	      skipFunctionalTests: true
	    },
	    mpegTsBitmovinHevc: {
	      url: 'https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/v720p_ts.m3u8',
	      description: 'HLS M2TS by Bitmovin (HEVC Main, many NALUs overflowing PESes, video only)',
	      abr: false,
	      skipFunctionalTests: true
	    }
	  };
	  return testStreams$1;
	}

	var main = {};

	/*
	 Copyright (c) 2013, Rodrigo Gonz√°lez, Sapienlab All Rights Reserved.
	 Available via MIT LICENSE. See https://github.com/roro89/jsonpack/blob/master/LICENSE.md for details.
	 */

	var hasRequiredMain;

	function requireMain () {
		if (hasRequiredMain) return main;
		hasRequiredMain = 1;
		(function (exports) {
			(function(define) {

				define([], function() {

					var TOKEN_TRUE = -1;
					var TOKEN_FALSE = -2;
					var TOKEN_NULL = -3;
					var TOKEN_EMPTY_STRING = -4;
					var TOKEN_UNDEFINED = -5;

					var pack = function(json, options) {

						// Canonizes the options
						options = options || {};

						// A shorthand for debugging
						var verbose = options.verbose || false;

						verbose && console.log('Normalize the JSON Object');

						// JSON as Javascript Object (Not string representation)
						json = typeof json === 'string' ? this.JSON.parse(json) : json;

						verbose && console.log('Creating a empty dictionary');

						// The dictionary
						var dictionary = {
							strings : [],
							integers : [],
							floats : []
						};

						verbose && console.log('Creating the AST');

						// The AST
						var ast = (function recursiveAstBuilder(item) {

							verbose && console.log('Calling recursiveAstBuilder with ' + this.JSON.stringify(item));

							// The type of the item
							var type = typeof item;

							// Case 7: The item is null
							if (item === null) {
								return {
									type : 'null',
									index : TOKEN_NULL
								};
							}
							
							//add undefined 
							if (typeof item === 'undefined') {
								return {
									type : 'undefined',
									index : TOKEN_UNDEFINED
								};
							}

							// Case 1: The item is Array Object
							if ( item instanceof Array) {

								// Create a new sub-AST of type Array (@)
								var ast = ['@'];

								// Add each items
								for (var i in item) {
									
									if (!item.hasOwnProperty(i)) continue;

									ast.push(recursiveAstBuilder(item[i]));
								}

								// And return
								return ast;

							}

							// Case 2: The item is Object
							if (type === 'object') {

								// Create a new sub-AST of type Object ($)
								var ast = ['$'];

								// Add each items
								for (var key in item) {

									if (!item.hasOwnProperty(key))
										continue;

									ast.push(recursiveAstBuilder(key));
									ast.push(recursiveAstBuilder(item[key]));
								}

								// And return
								return ast;

							}

							// Case 3: The item empty string
							if (item === '') {
								return {
									type : 'empty',
									index : TOKEN_EMPTY_STRING
								};
							}

							// Case 4: The item is String
							if (type === 'string') {

								// The index of that word in the dictionary
								var index = _indexOf.call(dictionary.strings, item);

								// If not, add to the dictionary and actualize the index
								if (index == -1) {
									dictionary.strings.push(_encode(item));
									index = dictionary.strings.length - 1;
								}

								// Return the token
								return {
									type : 'strings',
									index : index
								};
							}

							// Case 5: The item is integer
							if (type === 'number' && item % 1 === 0) {

								// The index of that number in the dictionary
								var index = _indexOf.call(dictionary.integers, item);

								// If not, add to the dictionary and actualize the index
								if (index == -1) {
									dictionary.integers.push(_base10To36(item));
									index = dictionary.integers.length - 1;
								}

								// Return the token
								return {
									type : 'integers',
									index : index
								};
							}

							// Case 6: The item is float
							if (type === 'number') {
								// The index of that number in the dictionary
								var index = _indexOf.call(dictionary.floats, item);

								// If not, add to the dictionary and actualize the index
								if (index == -1) {
									// Float not use base 36
									dictionary.floats.push(item);
									index = dictionary.floats.length - 1;
								}

								// Return the token
								return {
									type : 'floats',
									index : index
								};
							}

							// Case 7: The item is boolean
							if (type === 'boolean') {
								return {
									type : 'boolean',
									index : item ? TOKEN_TRUE : TOKEN_FALSE
								};
							}

							// Default
							throw new Error('Unexpected argument of type ' + typeof (item));

						})(json);

						// A set of shorthands proxies for the length of the dictionaries
						var stringLength = dictionary.strings.length;
						var integerLength = dictionary.integers.length;
						dictionary.floats.length;

						verbose && console.log('Parsing the dictionary');

						// Create a raw dictionary
						var packed = dictionary.strings.join('|');
						packed += '^' + dictionary.integers.join('|');
						packed += '^' + dictionary.floats.join('|');

						verbose && console.log('Parsing the structure');

						// And add the structure
						packed += '^' + (function recursiveParser(item) {

							verbose && console.log('Calling a recursiveParser with ' + this.JSON.stringify(item));

							// If the item is Array, then is a object of
							// type [object Object] or [object Array]
							if ( item instanceof Array) {

								// The packed resulting
								var packed = item.shift();

								for (var i in item) {
									
									if (!item.hasOwnProperty(i)) 
										continue;
									
									packed += recursiveParser(item[i]) + '|';
								}

								return (packed[packed.length - 1] === '|' ? packed.slice(0, -1) : packed) + ']';

							}

							// A shorthand proxies
							var type = item.type, index = item.index;

							if (type === 'strings') {
								// Just return the base 36 of index
								return _base10To36(index);
							}

							if (type === 'integers') {
								// Return a base 36 of index plus stringLength offset
								return _base10To36(stringLength + index);
							}

							if (type === 'floats') {
								// Return a base 36 of index plus stringLength and integerLength offset
								return _base10To36(stringLength + integerLength + index);
							}

							if (type === 'boolean') {
								return item.index;
							}

							if (type === 'null') {
								return TOKEN_NULL;
							}

							if (type === 'undefined') {
								return TOKEN_UNDEFINED;
							}

							if (type === 'empty') {
								return TOKEN_EMPTY_STRING;
							}

							throw new TypeError('The item is alien!');

						})(ast);

						verbose && console.log('Ending parser');

						// If debug, return a internal representation of dictionary and stuff
						if (options.debug)
							return {
								dictionary : dictionary,
								ast : ast,
								packed : packed
							};

						return packed;

					};

					var unpack = function(packed, options) {

						// Canonizes the options
						options = options || {};

						// A raw buffer
						var rawBuffers = packed.split('^');

						// Create a dictionary
						options.verbose && console.log('Building dictionary');
						var dictionary = [];

						// Add the strings values
						var buffer = rawBuffers[0];
						if (buffer !== '') {
							buffer = buffer.split('|');
							options.verbose && console.log('Parse the strings dictionary');
							for (var i=0, n=buffer.length; i<n; i++){
								dictionary.push(_decode(buffer[i]));
							}
						}

						// Add the integers values
						buffer = rawBuffers[1];
						if (buffer !== '') {
							buffer = buffer.split('|');
							options.verbose && console.log('Parse the integers dictionary');
							for (var i=0, n=buffer.length; i<n; i++){
								dictionary.push(_base36To10(buffer[i]));
							}
						}

						// Add the floats values
						buffer = rawBuffers[2];
						if (buffer !== '') {
							buffer = buffer.split('|');
							options.verbose && console.log('Parse the floats dictionary');
							for (var i=0, n=buffer.length; i<n; i++){
								dictionary.push(parseFloat(buffer[i]));
							}
						}
						// Free memory
						buffer = null;

						options.verbose && console.log('Tokenizing the structure');

						// Tokenizer the structure
						var number36 = '';
						var tokens = [];
						var len=rawBuffers[3].length;
						for (var i = 0; i < len; i++) {
							var symbol = rawBuffers[3].charAt(i);
							if (symbol === '|' || symbol === '$' || symbol === '@' || symbol === ']') {
								if (number36) {
									tokens.push(_base36To10(number36));
									number36 = '';
								}
								symbol !== '|' && tokens.push(symbol);
							} else {
								number36 += symbol;
							}
						}

						// A shorthand proxy for tokens.length
						var tokensLength = tokens.length;

						// The index of the next token to read
						var tokensIndex = 0;

						options.verbose && console.log('Starting recursive parser');

						return (function recursiveUnpackerParser() {

							// Maybe '$' (object) or '@' (array)
							var type = tokens[tokensIndex++];

							options.verbose && console.log('Reading collection type ' + (type === '$' ? 'object' : 'Array'));

							// Parse an array
							if (type === '@') {

								var node = [];

								for (; tokensIndex < tokensLength; tokensIndex++) {
									var value = tokens[tokensIndex];
									options.verbose && console.log('Read ' + value + ' symbol');
									if (value === ']')
										return node;
									if (value === '@' || value === '$') {
										node.push(recursiveUnpackerParser());
									} else {
										switch(value) {
											case TOKEN_TRUE:
												node.push(true);
												break;
											case TOKEN_FALSE:
												node.push(false);
												break;
											case TOKEN_NULL:
												node.push(null);
												break;
											case TOKEN_UNDEFINED:
												node.push(undefined);
												break;
											case TOKEN_EMPTY_STRING:
												node.push('');
												break;
											default:
												node.push(dictionary[value]);
										}

									}
								}

								options.verbose && console.log('Parsed ' + this.JSON.stringify(node));

								return node;

							}

							// Parse a object
							if (type === '$') {
								var node = {};

								for (; tokensIndex < tokensLength; tokensIndex++) {

									var key = tokens[tokensIndex];

									if (key === ']')
										return node;

									if (key === TOKEN_EMPTY_STRING)
										key = '';
									else
										key = dictionary[key];

									var value = tokens[++tokensIndex];

									if (value === '@' || value === '$') {
										node[key] = recursiveUnpackerParser();
									} else {
										switch(value) {
											case TOKEN_TRUE:
												node[key] = true;
												break;
											case TOKEN_FALSE:
												node[key] = false;
												break;
											case TOKEN_NULL:
												node[key] = null;
												break;
											case TOKEN_UNDEFINED:
												node[key] = undefined;
												break;
											case TOKEN_EMPTY_STRING:
												node[key] = '';
												break;
											default:
												node[key] = dictionary[value];
										}

									}
								}

								options.verbose && console.log('Parsed ' + this.JSON.stringify(node));

								return node;
							}

							throw new TypeError('Bad token ' + type + ' isn\'t a type');

						})();

					};

					var _encode = function(str) {
						if ( typeof str !== 'string')
							return str;

						return str.replace(/[\+ \|\^\%]/g, function(a) {
							return ({
							' ' : '+',
							'+' : '%2B',
							'|' : '%7C',
							'^' : '%5E',
							'%' : '%25'
							})[a]
						});
					};

					var _decode = function(str) {
						if ( typeof str !== 'string')
							return str;

						return str.replace(/\+|%2B|%7C|%5E|%25/g, function(a) {
							return ({
							'+' : ' ',
							'%2B' : '+',
							'%7C' : '|',
							'%5E' : '^',
							'%25' : '%'
							})[a]
						})
					};

					var _base10To36 = function(number) {
						return Number.prototype.toString.call(number, 36).toUpperCase();
					};

					var _base36To10 = function(number) {
						return parseInt(number, 36);
					};

					var _indexOf = Array.prototype.indexOf ||
					function(obj, start) {
						for (var i = (start || 0), j = this.length; i < j; i++) {
							if (this[i] === obj) {
								return i;
							}
						}
						return -1;
					};

					return {
						JSON : JSON,
						pack : pack,
						unpack : unpack
					};

				});

			})( function(deps, factory) {
				var jsonpack = factory();
				for (var key in jsonpack)
					exports[key] = jsonpack[key];
			} ); 
		} (main));
		return main;
	}

	var mainExports = requireMain();

	/**
	 * @this {Promise}
	 */
	function finallyConstructor(callback) {
	  var constructor = this.constructor;
	  return this.then(
	    function(value) {
	      // @ts-ignore
	      return constructor.resolve(callback()).then(function() {
	        return value;
	      });
	    },
	    function(reason) {
	      // @ts-ignore
	      return constructor.resolve(callback()).then(function() {
	        // @ts-ignore
	        return constructor.reject(reason);
	      });
	    }
	  );
	}

	function allSettled(arr) {
	  var P = this;
	  return new P(function(resolve, reject) {
	    if (!(arr && typeof arr.length !== 'undefined')) {
	      return reject(
	        new TypeError(
	          typeof arr +
	            ' ' +
	            arr +
	            ' is not iterable(cannot read property Symbol(Symbol.iterator))'
	        )
	      );
	    }
	    var args = Array.prototype.slice.call(arr);
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;

	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        var then = val.then;
	        if (typeof then === 'function') {
	          then.call(
	            val,
	            function(val) {
	              res(i, val);
	            },
	            function(e) {
	              args[i] = { status: 'rejected', reason: e };
	              if (--remaining === 0) {
	                resolve(args);
	              }
	            }
	          );
	          return;
	        }
	      }
	      args[i] = { status: 'fulfilled', value: val };
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }

	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	}

	/**
	 * @constructor
	 */
	function AggregateError(errors, message) {
	  (this.name = 'AggregateError'), (this.errors = errors);
	  this.message = message || '';
	}
	AggregateError.prototype = Error.prototype;

	function any(arr) {
	  var P = this;
	  return new P(function(resolve, reject) {
	    if (!(arr && typeof arr.length !== 'undefined')) {
	      return reject(new TypeError('Promise.any accepts an array'));
	    }

	    var args = Array.prototype.slice.call(arr);
	    if (args.length === 0) return reject();

	    var rejectionReasons = [];
	    for (var i = 0; i < args.length; i++) {
	      try {
	        P.resolve(args[i])
	          .then(resolve)
	          .catch(function(error) {
	            rejectionReasons.push(error);
	            if (rejectionReasons.length === args.length) {
	              reject(
	                new AggregateError(
	                  rejectionReasons,
	                  'All promises were rejected'
	                )
	              );
	            }
	          });
	      } catch (ex) {
	        reject(ex);
	      }
	    }
	  });
	}

	// Store setTimeout reference so promise-polyfill will be unaffected by
	// other code modifying setTimeout (like sinon.useFakeTimers())
	var setTimeoutFunc = setTimeout;

	function isArray(x) {
	  return Boolean(x && typeof x.length !== 'undefined');
	}

	function noop() {}

	// Polyfill for Function.prototype.bind
	function bind(fn, thisArg) {
	  return function() {
	    fn.apply(thisArg, arguments);
	  };
	}

	/**
	 * @constructor
	 * @param {Function} fn
	 */
	function Promise$1(fn) {
	  if (!(this instanceof Promise$1))
	    throw new TypeError('Promises must be constructed via new');
	  if (typeof fn !== 'function') throw new TypeError('not a function');
	  /** @type {!number} */
	  this._state = 0;
	  /** @type {!boolean} */
	  this._handled = false;
	  /** @type {Promise|undefined} */
	  this._value = undefined;
	  /** @type {!Array<!Function>} */
	  this._deferreds = [];

	  doResolve(fn, this);
	}

	function handle(self, deferred) {
	  while (self._state === 3) {
	    self = self._value;
	  }
	  if (self._state === 0) {
	    self._deferreds.push(deferred);
	    return;
	  }
	  self._handled = true;
	  Promise$1._immediateFn(function() {
	    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	      return;
	    }
	    var ret;
	    try {
	      ret = cb(self._value);
	    } catch (e) {
	      reject(deferred.promise, e);
	      return;
	    }
	    resolve(deferred.promise, ret);
	  });
	}

	function resolve(self, newValue) {
	  try {
	    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	    if (newValue === self)
	      throw new TypeError('A promise cannot be resolved with itself.');
	    if (
	      newValue &&
	      (typeof newValue === 'object' || typeof newValue === 'function')
	    ) {
	      var then = newValue.then;
	      if (newValue instanceof Promise$1) {
	        self._state = 3;
	        self._value = newValue;
	        finale(self);
	        return;
	      } else if (typeof then === 'function') {
	        doResolve(bind(then, newValue), self);
	        return;
	      }
	    }
	    self._state = 1;
	    self._value = newValue;
	    finale(self);
	  } catch (e) {
	    reject(self, e);
	  }
	}

	function reject(self, newValue) {
	  self._state = 2;
	  self._value = newValue;
	  finale(self);
	}

	function finale(self) {
	  if (self._state === 2 && self._deferreds.length === 0) {
	    Promise$1._immediateFn(function() {
	      if (!self._handled) {
	        Promise$1._unhandledRejectionFn(self._value);
	      }
	    });
	  }

	  for (var i = 0, len = self._deferreds.length; i < len; i++) {
	    handle(self, self._deferreds[i]);
	  }
	  self._deferreds = null;
	}

	/**
	 * @constructor
	 */
	function Handler(onFulfilled, onRejected, promise) {
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, self) {
	  var done = false;
	  try {
	    fn(
	      function(value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      },
	      function(reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      }
	    );
	  } catch (ex) {
	    if (done) return;
	    done = true;
	    reject(self, ex);
	  }
	}

	Promise$1.prototype['catch'] = function(onRejected) {
	  return this.then(null, onRejected);
	};

	Promise$1.prototype.then = function(onFulfilled, onRejected) {
	  // @ts-ignore
	  var prom = new this.constructor(noop);

	  handle(this, new Handler(onFulfilled, onRejected, prom));
	  return prom;
	};

	Promise$1.prototype['finally'] = finallyConstructor;

	Promise$1.all = function(arr) {
	  return new Promise$1(function(resolve, reject) {
	    if (!isArray(arr)) {
	      return reject(new TypeError('Promise.all accepts an array'));
	    }

	    var args = Array.prototype.slice.call(arr);
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;

	    function res(i, val) {
	      try {
	        if (val && (typeof val === 'object' || typeof val === 'function')) {
	          var then = val.then;
	          if (typeof then === 'function') {
	            then.call(
	              val,
	              function(val) {
	                res(i, val);
	              },
	              reject
	            );
	            return;
	          }
	        }
	        args[i] = val;
	        if (--remaining === 0) {
	          resolve(args);
	        }
	      } catch (ex) {
	        reject(ex);
	      }
	    }

	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};

	Promise$1.any = any;

	Promise$1.allSettled = allSettled;

	Promise$1.resolve = function(value) {
	  if (value && typeof value === 'object' && value.constructor === Promise$1) {
	    return value;
	  }

	  return new Promise$1(function(resolve) {
	    resolve(value);
	  });
	};

	Promise$1.reject = function(value) {
	  return new Promise$1(function(resolve, reject) {
	    reject(value);
	  });
	};

	Promise$1.race = function(arr) {
	  return new Promise$1(function(resolve, reject) {
	    if (!isArray(arr)) {
	      return reject(new TypeError('Promise.race accepts an array'));
	    }

	    for (var i = 0, len = arr.length; i < len; i++) {
	      Promise$1.resolve(arr[i]).then(resolve, reject);
	    }
	  });
	};

	// Use polyfill for setImmediate for performance gains
	Promise$1._immediateFn =
	  // @ts-ignore
	  (typeof setImmediate === 'function' &&
	    function(fn) {
	      // @ts-ignore
	      setImmediate(fn);
	    }) ||
	  function(fn) {
	    setTimeoutFunc(fn, 0);
	  };

	Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
	  if (typeof console !== 'undefined' && console) {
	    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	  }
	};

	/** @suppress {undefinedVars} */
	var globalNS = (function() {
	  // the only reliable means to get the global object is
	  // `Function('return this')()`
	  // However, this causes CSP violations in Chrome apps.
	  if (typeof self !== 'undefined') {
	    return self;
	  }
	  if (typeof window !== 'undefined') {
	    return window;
	  }
	  if (typeof global !== 'undefined') {
	    return global;
	  }
	  throw new Error('unable to locate global object');
	})();

	// Expose the polyfill if Promise is undefined or set to a
	// non-function value. The latter can be due to a named HTMLElement
	// being exposed by browsers for legacy reasons.
	// https://github.com/taylorhakes/promise-polyfill/issues/114
	if (typeof globalNS['Promise'] !== 'function') {
	  globalNS['Promise'] = Promise$1;
	} else {
	  if (!globalNS.Promise.prototype['finally']) {
	    globalNS.Promise.prototype['finally'] = finallyConstructor;
	  }
	  if (!globalNS.Promise.allSettled) {
	    globalNS.Promise.allSettled = allSettled;
	  }
	  if (!globalNS.Promise.any) {
	    globalNS.Promise.any = any;
	  }
	}

	function sortObject(obj) {
	  if (typeof obj !== 'object') {
	    return obj;
	  }
	  var temp = {};
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }
	  keys.sort();
	  for (var index in keys) {
	    temp[keys[index]] = sortObject(obj[keys[index]]);
	  }
	  return temp;
	}
	function copyTextToClipboard(text) {
	  var textArea = document.createElement('textarea');
	  textArea.value = text;
	  document.body.appendChild(textArea);
	  textArea.select();
	  try {
	    var successful = document.execCommand('copy');
	    var msg = successful ? 'successful' : 'unsuccessful';
	    console.log('Copying text command was ' + msg);
	  } catch (err) {
	    console.log('Oops, unable to copy');
	  }
	  document.body.removeChild(textArea);
	}

	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
	    writable: false
	  }), e;
	}
	function _extends() {
	  return _extends = Object.assign ? Object.assign.bind() : function (n) {
	    for (var e = 1; e < arguments.length; e++) {
	      var t = arguments[e];
	      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
	    }
	    return n;
	  }, _extends.apply(null, arguments);
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r);
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (String )(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}

	var Chart$2 = {exports: {}};

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var moment$1 = {exports: {}};

	var moment = moment$1.exports;

	var hasRequiredMoment;

	function requireMoment () {
		if (hasRequiredMoment) return moment$1.exports;
		hasRequiredMoment = 1;
		(function (module, exports) {
	(function (global, factory) {
			    module.exports = factory() ;
			}(moment, (function () {
			    var hookCallback;

			    function hooks() {
			        return hookCallback.apply(null, arguments);
			    }

			    // This is done to register the method called with moment()
			    // without creating circular dependencies.
			    function setHookCallback(callback) {
			        hookCallback = callback;
			    }

			    function isArray(input) {
			        return (
			            input instanceof Array ||
			            Object.prototype.toString.call(input) === '[object Array]'
			        );
			    }

			    function isObject(input) {
			        // IE8 will treat undefined and null as object if it wasn't for
			        // input != null
			        return (
			            input != null &&
			            Object.prototype.toString.call(input) === '[object Object]'
			        );
			    }

			    function hasOwnProp(a, b) {
			        return Object.prototype.hasOwnProperty.call(a, b);
			    }

			    function isObjectEmpty(obj) {
			        if (Object.getOwnPropertyNames) {
			            return Object.getOwnPropertyNames(obj).length === 0;
			        } else {
			            var k;
			            for (k in obj) {
			                if (hasOwnProp(obj, k)) {
			                    return false;
			                }
			            }
			            return true;
			        }
			    }

			    function isUndefined(input) {
			        return input === void 0;
			    }

			    function isNumber(input) {
			        return (
			            typeof input === 'number' ||
			            Object.prototype.toString.call(input) === '[object Number]'
			        );
			    }

			    function isDate(input) {
			        return (
			            input instanceof Date ||
			            Object.prototype.toString.call(input) === '[object Date]'
			        );
			    }

			    function map(arr, fn) {
			        var res = [],
			            i,
			            arrLen = arr.length;
			        for (i = 0; i < arrLen; ++i) {
			            res.push(fn(arr[i], i));
			        }
			        return res;
			    }

			    function extend(a, b) {
			        for (var i in b) {
			            if (hasOwnProp(b, i)) {
			                a[i] = b[i];
			            }
			        }

			        if (hasOwnProp(b, 'toString')) {
			            a.toString = b.toString;
			        }

			        if (hasOwnProp(b, 'valueOf')) {
			            a.valueOf = b.valueOf;
			        }

			        return a;
			    }

			    function createUTC(input, format, locale, strict) {
			        return createLocalOrUTC(input, format, locale, strict, true).utc();
			    }

			    function defaultParsingFlags() {
			        // We need to deep clone this object.
			        return {
			            empty: false,
			            unusedTokens: [],
			            unusedInput: [],
			            overflow: -2,
			            charsLeftOver: 0,
			            nullInput: false,
			            invalidEra: null,
			            invalidMonth: null,
			            invalidFormat: false,
			            userInvalidated: false,
			            iso: false,
			            parsedDateParts: [],
			            era: null,
			            meridiem: null,
			            rfc2822: false,
			            weekdayMismatch: false,
			        };
			    }

			    function getParsingFlags(m) {
			        if (m._pf == null) {
			            m._pf = defaultParsingFlags();
			        }
			        return m._pf;
			    }

			    var some;
			    if (Array.prototype.some) {
			        some = Array.prototype.some;
			    } else {
			        some = function (fun) {
			            var t = Object(this),
			                len = t.length >>> 0,
			                i;

			            for (i = 0; i < len; i++) {
			                if (i in t && fun.call(this, t[i], i, t)) {
			                    return true;
			                }
			            }

			            return false;
			        };
			    }

			    function isValid(m) {
			        if (m._isValid == null) {
			            var flags = getParsingFlags(m),
			                parsedParts = some.call(flags.parsedDateParts, function (i) {
			                    return i != null;
			                }),
			                isNowValid =
			                    !isNaN(m._d.getTime()) &&
			                    flags.overflow < 0 &&
			                    !flags.empty &&
			                    !flags.invalidEra &&
			                    !flags.invalidMonth &&
			                    !flags.invalidWeekday &&
			                    !flags.weekdayMismatch &&
			                    !flags.nullInput &&
			                    !flags.invalidFormat &&
			                    !flags.userInvalidated &&
			                    (!flags.meridiem || (flags.meridiem && parsedParts));

			            if (m._strict) {
			                isNowValid =
			                    isNowValid &&
			                    flags.charsLeftOver === 0 &&
			                    flags.unusedTokens.length === 0 &&
			                    flags.bigHour === undefined;
			            }

			            if (Object.isFrozen == null || !Object.isFrozen(m)) {
			                m._isValid = isNowValid;
			            } else {
			                return isNowValid;
			            }
			        }
			        return m._isValid;
			    }

			    function createInvalid(flags) {
			        var m = createUTC(NaN);
			        if (flags != null) {
			            extend(getParsingFlags(m), flags);
			        } else {
			            getParsingFlags(m).userInvalidated = true;
			        }

			        return m;
			    }

			    // Plugins that add properties should also add the key here (null value),
			    // so we can properly clone ourselves.
			    var momentProperties = (hooks.momentProperties = []),
			        updateInProgress = false;

			    function copyConfig(to, from) {
			        var i,
			            prop,
			            val,
			            momentPropertiesLen = momentProperties.length;

			        if (!isUndefined(from._isAMomentObject)) {
			            to._isAMomentObject = from._isAMomentObject;
			        }
			        if (!isUndefined(from._i)) {
			            to._i = from._i;
			        }
			        if (!isUndefined(from._f)) {
			            to._f = from._f;
			        }
			        if (!isUndefined(from._l)) {
			            to._l = from._l;
			        }
			        if (!isUndefined(from._strict)) {
			            to._strict = from._strict;
			        }
			        if (!isUndefined(from._tzm)) {
			            to._tzm = from._tzm;
			        }
			        if (!isUndefined(from._isUTC)) {
			            to._isUTC = from._isUTC;
			        }
			        if (!isUndefined(from._offset)) {
			            to._offset = from._offset;
			        }
			        if (!isUndefined(from._pf)) {
			            to._pf = getParsingFlags(from);
			        }
			        if (!isUndefined(from._locale)) {
			            to._locale = from._locale;
			        }

			        if (momentPropertiesLen > 0) {
			            for (i = 0; i < momentPropertiesLen; i++) {
			                prop = momentProperties[i];
			                val = from[prop];
			                if (!isUndefined(val)) {
			                    to[prop] = val;
			                }
			            }
			        }

			        return to;
			    }

			    // Moment prototype object
			    function Moment(config) {
			        copyConfig(this, config);
			        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
			        if (!this.isValid()) {
			            this._d = new Date(NaN);
			        }
			        // Prevent infinite loop in case updateOffset creates new moment
			        // objects.
			        if (updateInProgress === false) {
			            updateInProgress = true;
			            hooks.updateOffset(this);
			            updateInProgress = false;
			        }
			    }

			    function isMoment(obj) {
			        return (
			            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
			        );
			    }

			    function warn(msg) {
			        if (
			            hooks.suppressDeprecationWarnings === false &&
			            typeof console !== 'undefined' &&
			            console.warn
			        ) {
			            console.warn('Deprecation warning: ' + msg);
			        }
			    }

			    function deprecate(msg, fn) {
			        var firstTime = true;

			        return extend(function () {
			            if (hooks.deprecationHandler != null) {
			                hooks.deprecationHandler(null, msg);
			            }
			            if (firstTime) {
			                var args = [],
			                    arg,
			                    i,
			                    key,
			                    argLen = arguments.length;
			                for (i = 0; i < argLen; i++) {
			                    arg = '';
			                    if (typeof arguments[i] === 'object') {
			                        arg += '\n[' + i + '] ';
			                        for (key in arguments[0]) {
			                            if (hasOwnProp(arguments[0], key)) {
			                                arg += key + ': ' + arguments[0][key] + ', ';
			                            }
			                        }
			                        arg = arg.slice(0, -2); // Remove trailing comma and space
			                    } else {
			                        arg = arguments[i];
			                    }
			                    args.push(arg);
			                }
			                warn(
			                    msg +
			                        '\nArguments: ' +
			                        Array.prototype.slice.call(args).join('') +
			                        '\n' +
			                        new Error().stack
			                );
			                firstTime = false;
			            }
			            return fn.apply(this, arguments);
			        }, fn);
			    }

			    var deprecations = {};

			    function deprecateSimple(name, msg) {
			        if (hooks.deprecationHandler != null) {
			            hooks.deprecationHandler(name, msg);
			        }
			        if (!deprecations[name]) {
			            warn(msg);
			            deprecations[name] = true;
			        }
			    }

			    hooks.suppressDeprecationWarnings = false;
			    hooks.deprecationHandler = null;

			    function isFunction(input) {
			        return (
			            (typeof Function !== 'undefined' && input instanceof Function) ||
			            Object.prototype.toString.call(input) === '[object Function]'
			        );
			    }

			    function set(config) {
			        var prop, i;
			        for (i in config) {
			            if (hasOwnProp(config, i)) {
			                prop = config[i];
			                if (isFunction(prop)) {
			                    this[i] = prop;
			                } else {
			                    this['_' + i] = prop;
			                }
			            }
			        }
			        this._config = config;
			        // Lenient ordinal parsing accepts just a number in addition to
			        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
			        // TODO: Remove "ordinalParse" fallback in next major release.
			        this._dayOfMonthOrdinalParseLenient = new RegExp(
			            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
			                '|' +
			                /\d{1,2}/.source
			        );
			    }

			    function mergeConfigs(parentConfig, childConfig) {
			        var res = extend({}, parentConfig),
			            prop;
			        for (prop in childConfig) {
			            if (hasOwnProp(childConfig, prop)) {
			                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
			                    res[prop] = {};
			                    extend(res[prop], parentConfig[prop]);
			                    extend(res[prop], childConfig[prop]);
			                } else if (childConfig[prop] != null) {
			                    res[prop] = childConfig[prop];
			                } else {
			                    delete res[prop];
			                }
			            }
			        }
			        for (prop in parentConfig) {
			            if (
			                hasOwnProp(parentConfig, prop) &&
			                !hasOwnProp(childConfig, prop) &&
			                isObject(parentConfig[prop])
			            ) {
			                // make sure changes to properties don't modify parent config
			                res[prop] = extend({}, res[prop]);
			            }
			        }
			        return res;
			    }

			    function Locale(config) {
			        if (config != null) {
			            this.set(config);
			        }
			    }

			    var keys;

			    if (Object.keys) {
			        keys = Object.keys;
			    } else {
			        keys = function (obj) {
			            var i,
			                res = [];
			            for (i in obj) {
			                if (hasOwnProp(obj, i)) {
			                    res.push(i);
			                }
			            }
			            return res;
			        };
			    }

			    var defaultCalendar = {
			        sameDay: '[Today at] LT',
			        nextDay: '[Tomorrow at] LT',
			        nextWeek: 'dddd [at] LT',
			        lastDay: '[Yesterday at] LT',
			        lastWeek: '[Last] dddd [at] LT',
			        sameElse: 'L',
			    };

			    function calendar(key, mom, now) {
			        var output = this._calendar[key] || this._calendar['sameElse'];
			        return isFunction(output) ? output.call(mom, now) : output;
			    }

			    function zeroFill(number, targetLength, forceSign) {
			        var absNumber = '' + Math.abs(number),
			            zerosToFill = targetLength - absNumber.length,
			            sign = number >= 0;
			        return (
			            (sign ? (forceSign ? '+' : '') : '-') +
			            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
			            absNumber
			        );
			    }

			    var formattingTokens =
			            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
			        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
			        formatFunctions = {},
			        formatTokenFunctions = {};

			    // token:    'M'
			    // padded:   ['MM', 2]
			    // ordinal:  'Mo'
			    // callback: function () { this.month() + 1 }
			    function addFormatToken(token, padded, ordinal, callback) {
			        var func = callback;
			        if (typeof callback === 'string') {
			            func = function () {
			                return this[callback]();
			            };
			        }
			        if (token) {
			            formatTokenFunctions[token] = func;
			        }
			        if (padded) {
			            formatTokenFunctions[padded[0]] = function () {
			                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
			            };
			        }
			        if (ordinal) {
			            formatTokenFunctions[ordinal] = function () {
			                return this.localeData().ordinal(
			                    func.apply(this, arguments),
			                    token
			                );
			            };
			        }
			    }

			    function removeFormattingTokens(input) {
			        if (input.match(/\[[\s\S]/)) {
			            return input.replace(/^\[|\]$/g, '');
			        }
			        return input.replace(/\\/g, '');
			    }

			    function makeFormatFunction(format) {
			        var array = format.match(formattingTokens),
			            i,
			            length;

			        for (i = 0, length = array.length; i < length; i++) {
			            if (formatTokenFunctions[array[i]]) {
			                array[i] = formatTokenFunctions[array[i]];
			            } else {
			                array[i] = removeFormattingTokens(array[i]);
			            }
			        }

			        return function (mom) {
			            var output = '',
			                i;
			            for (i = 0; i < length; i++) {
			                output += isFunction(array[i])
			                    ? array[i].call(mom, format)
			                    : array[i];
			            }
			            return output;
			        };
			    }

			    // format date using native date object
			    function formatMoment(m, format) {
			        if (!m.isValid()) {
			            return m.localeData().invalidDate();
			        }

			        format = expandFormat(format, m.localeData());
			        formatFunctions[format] =
			            formatFunctions[format] || makeFormatFunction(format);

			        return formatFunctions[format](m);
			    }

			    function expandFormat(format, locale) {
			        var i = 5;

			        function replaceLongDateFormatTokens(input) {
			            return locale.longDateFormat(input) || input;
			        }

			        localFormattingTokens.lastIndex = 0;
			        while (i >= 0 && localFormattingTokens.test(format)) {
			            format = format.replace(
			                localFormattingTokens,
			                replaceLongDateFormatTokens
			            );
			            localFormattingTokens.lastIndex = 0;
			            i -= 1;
			        }

			        return format;
			    }

			    var defaultLongDateFormat = {
			        LTS: 'h:mm:ss A',
			        LT: 'h:mm A',
			        L: 'MM/DD/YYYY',
			        LL: 'MMMM D, YYYY',
			        LLL: 'MMMM D, YYYY h:mm A',
			        LLLL: 'dddd, MMMM D, YYYY h:mm A',
			    };

			    function longDateFormat(key) {
			        var format = this._longDateFormat[key],
			            formatUpper = this._longDateFormat[key.toUpperCase()];

			        if (format || !formatUpper) {
			            return format;
			        }

			        this._longDateFormat[key] = formatUpper
			            .match(formattingTokens)
			            .map(function (tok) {
			                if (
			                    tok === 'MMMM' ||
			                    tok === 'MM' ||
			                    tok === 'DD' ||
			                    tok === 'dddd'
			                ) {
			                    return tok.slice(1);
			                }
			                return tok;
			            })
			            .join('');

			        return this._longDateFormat[key];
			    }

			    var defaultInvalidDate = 'Invalid date';

			    function invalidDate() {
			        return this._invalidDate;
			    }

			    var defaultOrdinal = '%d',
			        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

			    function ordinal(number) {
			        return this._ordinal.replace('%d', number);
			    }

			    var defaultRelativeTime = {
			        future: 'in %s',
			        past: '%s ago',
			        s: 'a few seconds',
			        ss: '%d seconds',
			        m: 'a minute',
			        mm: '%d minutes',
			        h: 'an hour',
			        hh: '%d hours',
			        d: 'a day',
			        dd: '%d days',
			        w: 'a week',
			        ww: '%d weeks',
			        M: 'a month',
			        MM: '%d months',
			        y: 'a year',
			        yy: '%d years',
			    };

			    function relativeTime(number, withoutSuffix, string, isFuture) {
			        var output = this._relativeTime[string];
			        return isFunction(output)
			            ? output(number, withoutSuffix, string, isFuture)
			            : output.replace(/%d/i, number);
			    }

			    function pastFuture(diff, output) {
			        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
			        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
			    }

			    var aliases = {};

			    function addUnitAlias(unit, shorthand) {
			        var lowerCase = unit.toLowerCase();
			        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
			    }

			    function normalizeUnits(units) {
			        return typeof units === 'string'
			            ? aliases[units] || aliases[units.toLowerCase()]
			            : undefined;
			    }

			    function normalizeObjectUnits(inputObject) {
			        var normalizedInput = {},
			            normalizedProp,
			            prop;

			        for (prop in inputObject) {
			            if (hasOwnProp(inputObject, prop)) {
			                normalizedProp = normalizeUnits(prop);
			                if (normalizedProp) {
			                    normalizedInput[normalizedProp] = inputObject[prop];
			                }
			            }
			        }

			        return normalizedInput;
			    }

			    var priorities = {};

			    function addUnitPriority(unit, priority) {
			        priorities[unit] = priority;
			    }

			    function getPrioritizedUnits(unitsObj) {
			        var units = [],
			            u;
			        for (u in unitsObj) {
			            if (hasOwnProp(unitsObj, u)) {
			                units.push({ unit: u, priority: priorities[u] });
			            }
			        }
			        units.sort(function (a, b) {
			            return a.priority - b.priority;
			        });
			        return units;
			    }

			    function isLeapYear(year) {
			        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
			    }

			    function absFloor(number) {
			        if (number < 0) {
			            // -0 -> 0
			            return Math.ceil(number) || 0;
			        } else {
			            return Math.floor(number);
			        }
			    }

			    function toInt(argumentForCoercion) {
			        var coercedNumber = +argumentForCoercion,
			            value = 0;

			        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
			            value = absFloor(coercedNumber);
			        }

			        return value;
			    }

			    function makeGetSet(unit, keepTime) {
			        return function (value) {
			            if (value != null) {
			                set$1(this, unit, value);
			                hooks.updateOffset(this, keepTime);
			                return this;
			            } else {
			                return get(this, unit);
			            }
			        };
			    }

			    function get(mom, unit) {
			        return mom.isValid()
			            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
			            : NaN;
			    }

			    function set$1(mom, unit, value) {
			        if (mom.isValid() && !isNaN(value)) {
			            if (
			                unit === 'FullYear' &&
			                isLeapYear(mom.year()) &&
			                mom.month() === 1 &&
			                mom.date() === 29
			            ) {
			                value = toInt(value);
			                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
			                    value,
			                    mom.month(),
			                    daysInMonth(value, mom.month())
			                );
			            } else {
			                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
			            }
			        }
			    }

			    // MOMENTS

			    function stringGet(units) {
			        units = normalizeUnits(units);
			        if (isFunction(this[units])) {
			            return this[units]();
			        }
			        return this;
			    }

			    function stringSet(units, value) {
			        if (typeof units === 'object') {
			            units = normalizeObjectUnits(units);
			            var prioritized = getPrioritizedUnits(units),
			                i,
			                prioritizedLen = prioritized.length;
			            for (i = 0; i < prioritizedLen; i++) {
			                this[prioritized[i].unit](units[prioritized[i].unit]);
			            }
			        } else {
			            units = normalizeUnits(units);
			            if (isFunction(this[units])) {
			                return this[units](value);
			            }
			        }
			        return this;
			    }

			    var match1 = /\d/, //       0 - 9
			        match2 = /\d\d/, //      00 - 99
			        match3 = /\d{3}/, //     000 - 999
			        match4 = /\d{4}/, //    0000 - 9999
			        match6 = /[+-]?\d{6}/, // -999999 - 999999
			        match1to2 = /\d\d?/, //       0 - 99
			        match3to4 = /\d\d\d\d?/, //     999 - 9999
			        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
			        match1to3 = /\d{1,3}/, //       0 - 999
			        match1to4 = /\d{1,4}/, //       0 - 9999
			        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
			        matchUnsigned = /\d+/, //       0 - inf
			        matchSigned = /[+-]?\d+/, //    -inf - inf
			        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
			        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
			        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
			        // any word (or two) characters or numbers including two/three word month in arabic.
			        // includes scottish gaelic two word and hyphenated months
			        matchWord =
			            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
			        regexes;

			    regexes = {};

			    function addRegexToken(token, regex, strictRegex) {
			        regexes[token] = isFunction(regex)
			            ? regex
			            : function (isStrict, localeData) {
			                  return isStrict && strictRegex ? strictRegex : regex;
			              };
			    }

			    function getParseRegexForToken(token, config) {
			        if (!hasOwnProp(regexes, token)) {
			            return new RegExp(unescapeFormat(token));
			        }

			        return regexes[token](config._strict, config._locale);
			    }

			    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
			    function unescapeFormat(s) {
			        return regexEscape(
			            s
			                .replace('\\', '')
			                .replace(
			                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
			                    function (matched, p1, p2, p3, p4) {
			                        return p1 || p2 || p3 || p4;
			                    }
			                )
			        );
			    }

			    function regexEscape(s) {
			        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
			    }

			    var tokens = {};

			    function addParseToken(token, callback) {
			        var i,
			            func = callback,
			            tokenLen;
			        if (typeof token === 'string') {
			            token = [token];
			        }
			        if (isNumber(callback)) {
			            func = function (input, array) {
			                array[callback] = toInt(input);
			            };
			        }
			        tokenLen = token.length;
			        for (i = 0; i < tokenLen; i++) {
			            tokens[token[i]] = func;
			        }
			    }

			    function addWeekParseToken(token, callback) {
			        addParseToken(token, function (input, array, config, token) {
			            config._w = config._w || {};
			            callback(input, config._w, config, token);
			        });
			    }

			    function addTimeToArrayFromToken(token, input, config) {
			        if (input != null && hasOwnProp(tokens, token)) {
			            tokens[token](input, config._a, config, token);
			        }
			    }

			    var YEAR = 0,
			        MONTH = 1,
			        DATE = 2,
			        HOUR = 3,
			        MINUTE = 4,
			        SECOND = 5,
			        MILLISECOND = 6,
			        WEEK = 7,
			        WEEKDAY = 8;

			    function mod(n, x) {
			        return ((n % x) + x) % x;
			    }

			    var indexOf;

			    if (Array.prototype.indexOf) {
			        indexOf = Array.prototype.indexOf;
			    } else {
			        indexOf = function (o) {
			            // I know
			            var i;
			            for (i = 0; i < this.length; ++i) {
			                if (this[i] === o) {
			                    return i;
			                }
			            }
			            return -1;
			        };
			    }

			    function daysInMonth(year, month) {
			        if (isNaN(year) || isNaN(month)) {
			            return NaN;
			        }
			        var modMonth = mod(month, 12);
			        year += (month - modMonth) / 12;
			        return modMonth === 1
			            ? isLeapYear(year)
			                ? 29
			                : 28
			            : 31 - ((modMonth % 7) % 2);
			    }

			    // FORMATTING

			    addFormatToken('M', ['MM', 2], 'Mo', function () {
			        return this.month() + 1;
			    });

			    addFormatToken('MMM', 0, 0, function (format) {
			        return this.localeData().monthsShort(this, format);
			    });

			    addFormatToken('MMMM', 0, 0, function (format) {
			        return this.localeData().months(this, format);
			    });

			    // ALIASES

			    addUnitAlias('month', 'M');

			    // PRIORITY

			    addUnitPriority('month', 8);

			    // PARSING

			    addRegexToken('M', match1to2);
			    addRegexToken('MM', match1to2, match2);
			    addRegexToken('MMM', function (isStrict, locale) {
			        return locale.monthsShortRegex(isStrict);
			    });
			    addRegexToken('MMMM', function (isStrict, locale) {
			        return locale.monthsRegex(isStrict);
			    });

			    addParseToken(['M', 'MM'], function (input, array) {
			        array[MONTH] = toInt(input) - 1;
			    });

			    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
			        var month = config._locale.monthsParse(input, token, config._strict);
			        // if we didn't find a month name, mark the date as invalid.
			        if (month != null) {
			            array[MONTH] = month;
			        } else {
			            getParsingFlags(config).invalidMonth = input;
			        }
			    });

			    // LOCALES

			    var defaultLocaleMonths =
			            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
			                '_'
			            ),
			        defaultLocaleMonthsShort =
			            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
			        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
			        defaultMonthsShortRegex = matchWord,
			        defaultMonthsRegex = matchWord;

			    function localeMonths(m, format) {
			        if (!m) {
			            return isArray(this._months)
			                ? this._months
			                : this._months['standalone'];
			        }
			        return isArray(this._months)
			            ? this._months[m.month()]
			            : this._months[
			                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
			                      ? 'format'
			                      : 'standalone'
			              ][m.month()];
			    }

			    function localeMonthsShort(m, format) {
			        if (!m) {
			            return isArray(this._monthsShort)
			                ? this._monthsShort
			                : this._monthsShort['standalone'];
			        }
			        return isArray(this._monthsShort)
			            ? this._monthsShort[m.month()]
			            : this._monthsShort[
			                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
			              ][m.month()];
			    }

			    function handleStrictParse(monthName, format, strict) {
			        var i,
			            ii,
			            mom,
			            llc = monthName.toLocaleLowerCase();
			        if (!this._monthsParse) {
			            // this is not used
			            this._monthsParse = [];
			            this._longMonthsParse = [];
			            this._shortMonthsParse = [];
			            for (i = 0; i < 12; ++i) {
			                mom = createUTC([2000, i]);
			                this._shortMonthsParse[i] = this.monthsShort(
			                    mom,
			                    ''
			                ).toLocaleLowerCase();
			                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
			            }
			        }

			        if (strict) {
			            if (format === 'MMM') {
			                ii = indexOf.call(this._shortMonthsParse, llc);
			                return ii !== -1 ? ii : null;
			            } else {
			                ii = indexOf.call(this._longMonthsParse, llc);
			                return ii !== -1 ? ii : null;
			            }
			        } else {
			            if (format === 'MMM') {
			                ii = indexOf.call(this._shortMonthsParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._longMonthsParse, llc);
			                return ii !== -1 ? ii : null;
			            } else {
			                ii = indexOf.call(this._longMonthsParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._shortMonthsParse, llc);
			                return ii !== -1 ? ii : null;
			            }
			        }
			    }

			    function localeMonthsParse(monthName, format, strict) {
			        var i, mom, regex;

			        if (this._monthsParseExact) {
			            return handleStrictParse.call(this, monthName, format, strict);
			        }

			        if (!this._monthsParse) {
			            this._monthsParse = [];
			            this._longMonthsParse = [];
			            this._shortMonthsParse = [];
			        }

			        // TODO: add sorting
			        // Sorting makes sure if one month (or abbr) is a prefix of another
			        // see sorting in computeMonthsParse
			        for (i = 0; i < 12; i++) {
			            // make the regex if we don't have it already
			            mom = createUTC([2000, i]);
			            if (strict && !this._longMonthsParse[i]) {
			                this._longMonthsParse[i] = new RegExp(
			                    '^' + this.months(mom, '').replace('.', '') + '$',
			                    'i'
			                );
			                this._shortMonthsParse[i] = new RegExp(
			                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
			                    'i'
			                );
			            }
			            if (!strict && !this._monthsParse[i]) {
			                regex =
			                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
			                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
			            }
			            // test the regex
			            if (
			                strict &&
			                format === 'MMMM' &&
			                this._longMonthsParse[i].test(monthName)
			            ) {
			                return i;
			            } else if (
			                strict &&
			                format === 'MMM' &&
			                this._shortMonthsParse[i].test(monthName)
			            ) {
			                return i;
			            } else if (!strict && this._monthsParse[i].test(monthName)) {
			                return i;
			            }
			        }
			    }

			    // MOMENTS

			    function setMonth(mom, value) {
			        var dayOfMonth;

			        if (!mom.isValid()) {
			            // No op
			            return mom;
			        }

			        if (typeof value === 'string') {
			            if (/^\d+$/.test(value)) {
			                value = toInt(value);
			            } else {
			                value = mom.localeData().monthsParse(value);
			                // TODO: Another silent failure?
			                if (!isNumber(value)) {
			                    return mom;
			                }
			            }
			        }

			        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
			        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
			        return mom;
			    }

			    function getSetMonth(value) {
			        if (value != null) {
			            setMonth(this, value);
			            hooks.updateOffset(this, true);
			            return this;
			        } else {
			            return get(this, 'Month');
			        }
			    }

			    function getDaysInMonth() {
			        return daysInMonth(this.year(), this.month());
			    }

			    function monthsShortRegex(isStrict) {
			        if (this._monthsParseExact) {
			            if (!hasOwnProp(this, '_monthsRegex')) {
			                computeMonthsParse.call(this);
			            }
			            if (isStrict) {
			                return this._monthsShortStrictRegex;
			            } else {
			                return this._monthsShortRegex;
			            }
			        } else {
			            if (!hasOwnProp(this, '_monthsShortRegex')) {
			                this._monthsShortRegex = defaultMonthsShortRegex;
			            }
			            return this._monthsShortStrictRegex && isStrict
			                ? this._monthsShortStrictRegex
			                : this._monthsShortRegex;
			        }
			    }

			    function monthsRegex(isStrict) {
			        if (this._monthsParseExact) {
			            if (!hasOwnProp(this, '_monthsRegex')) {
			                computeMonthsParse.call(this);
			            }
			            if (isStrict) {
			                return this._monthsStrictRegex;
			            } else {
			                return this._monthsRegex;
			            }
			        } else {
			            if (!hasOwnProp(this, '_monthsRegex')) {
			                this._monthsRegex = defaultMonthsRegex;
			            }
			            return this._monthsStrictRegex && isStrict
			                ? this._monthsStrictRegex
			                : this._monthsRegex;
			        }
			    }

			    function computeMonthsParse() {
			        function cmpLenRev(a, b) {
			            return b.length - a.length;
			        }

			        var shortPieces = [],
			            longPieces = [],
			            mixedPieces = [],
			            i,
			            mom;
			        for (i = 0; i < 12; i++) {
			            // make the regex if we don't have it already
			            mom = createUTC([2000, i]);
			            shortPieces.push(this.monthsShort(mom, ''));
			            longPieces.push(this.months(mom, ''));
			            mixedPieces.push(this.months(mom, ''));
			            mixedPieces.push(this.monthsShort(mom, ''));
			        }
			        // Sorting makes sure if one month (or abbr) is a prefix of another it
			        // will match the longer piece.
			        shortPieces.sort(cmpLenRev);
			        longPieces.sort(cmpLenRev);
			        mixedPieces.sort(cmpLenRev);
			        for (i = 0; i < 12; i++) {
			            shortPieces[i] = regexEscape(shortPieces[i]);
			            longPieces[i] = regexEscape(longPieces[i]);
			        }
			        for (i = 0; i < 24; i++) {
			            mixedPieces[i] = regexEscape(mixedPieces[i]);
			        }

			        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
			        this._monthsShortRegex = this._monthsRegex;
			        this._monthsStrictRegex = new RegExp(
			            '^(' + longPieces.join('|') + ')',
			            'i'
			        );
			        this._monthsShortStrictRegex = new RegExp(
			            '^(' + shortPieces.join('|') + ')',
			            'i'
			        );
			    }

			    // FORMATTING

			    addFormatToken('Y', 0, 0, function () {
			        var y = this.year();
			        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
			    });

			    addFormatToken(0, ['YY', 2], 0, function () {
			        return this.year() % 100;
			    });

			    addFormatToken(0, ['YYYY', 4], 0, 'year');
			    addFormatToken(0, ['YYYYY', 5], 0, 'year');
			    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

			    // ALIASES

			    addUnitAlias('year', 'y');

			    // PRIORITIES

			    addUnitPriority('year', 1);

			    // PARSING

			    addRegexToken('Y', matchSigned);
			    addRegexToken('YY', match1to2, match2);
			    addRegexToken('YYYY', match1to4, match4);
			    addRegexToken('YYYYY', match1to6, match6);
			    addRegexToken('YYYYYY', match1to6, match6);

			    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
			    addParseToken('YYYY', function (input, array) {
			        array[YEAR] =
			            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
			    });
			    addParseToken('YY', function (input, array) {
			        array[YEAR] = hooks.parseTwoDigitYear(input);
			    });
			    addParseToken('Y', function (input, array) {
			        array[YEAR] = parseInt(input, 10);
			    });

			    // HELPERS

			    function daysInYear(year) {
			        return isLeapYear(year) ? 366 : 365;
			    }

			    // HOOKS

			    hooks.parseTwoDigitYear = function (input) {
			        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
			    };

			    // MOMENTS

			    var getSetYear = makeGetSet('FullYear', true);

			    function getIsLeapYear() {
			        return isLeapYear(this.year());
			    }

			    function createDate(y, m, d, h, M, s, ms) {
			        // can't just apply() to create a date:
			        // https://stackoverflow.com/q/181348
			        var date;
			        // the date constructor remaps years 0-99 to 1900-1999
			        if (y < 100 && y >= 0) {
			            // preserve leap years using a full 400 year cycle, then reset
			            date = new Date(y + 400, m, d, h, M, s, ms);
			            if (isFinite(date.getFullYear())) {
			                date.setFullYear(y);
			            }
			        } else {
			            date = new Date(y, m, d, h, M, s, ms);
			        }

			        return date;
			    }

			    function createUTCDate(y) {
			        var date, args;
			        // the Date.UTC function remaps years 0-99 to 1900-1999
			        if (y < 100 && y >= 0) {
			            args = Array.prototype.slice.call(arguments);
			            // preserve leap years using a full 400 year cycle, then reset
			            args[0] = y + 400;
			            date = new Date(Date.UTC.apply(null, args));
			            if (isFinite(date.getUTCFullYear())) {
			                date.setUTCFullYear(y);
			            }
			        } else {
			            date = new Date(Date.UTC.apply(null, arguments));
			        }

			        return date;
			    }

			    // start-of-first-week - start-of-year
			    function firstWeekOffset(year, dow, doy) {
			        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
			            fwd = 7 + dow - doy,
			            // first-week day local weekday -- which local weekday is fwd
			            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

			        return -fwdlw + fwd - 1;
			    }

			    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
			    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
			        var localWeekday = (7 + weekday - dow) % 7,
			            weekOffset = firstWeekOffset(year, dow, doy),
			            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
			            resYear,
			            resDayOfYear;

			        if (dayOfYear <= 0) {
			            resYear = year - 1;
			            resDayOfYear = daysInYear(resYear) + dayOfYear;
			        } else if (dayOfYear > daysInYear(year)) {
			            resYear = year + 1;
			            resDayOfYear = dayOfYear - daysInYear(year);
			        } else {
			            resYear = year;
			            resDayOfYear = dayOfYear;
			        }

			        return {
			            year: resYear,
			            dayOfYear: resDayOfYear,
			        };
			    }

			    function weekOfYear(mom, dow, doy) {
			        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
			            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
			            resWeek,
			            resYear;

			        if (week < 1) {
			            resYear = mom.year() - 1;
			            resWeek = week + weeksInYear(resYear, dow, doy);
			        } else if (week > weeksInYear(mom.year(), dow, doy)) {
			            resWeek = week - weeksInYear(mom.year(), dow, doy);
			            resYear = mom.year() + 1;
			        } else {
			            resYear = mom.year();
			            resWeek = week;
			        }

			        return {
			            week: resWeek,
			            year: resYear,
			        };
			    }

			    function weeksInYear(year, dow, doy) {
			        var weekOffset = firstWeekOffset(year, dow, doy),
			            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
			        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
			    }

			    // FORMATTING

			    addFormatToken('w', ['ww', 2], 'wo', 'week');
			    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

			    // ALIASES

			    addUnitAlias('week', 'w');
			    addUnitAlias('isoWeek', 'W');

			    // PRIORITIES

			    addUnitPriority('week', 5);
			    addUnitPriority('isoWeek', 5);

			    // PARSING

			    addRegexToken('w', match1to2);
			    addRegexToken('ww', match1to2, match2);
			    addRegexToken('W', match1to2);
			    addRegexToken('WW', match1to2, match2);

			    addWeekParseToken(
			        ['w', 'ww', 'W', 'WW'],
			        function (input, week, config, token) {
			            week[token.substr(0, 1)] = toInt(input);
			        }
			    );

			    // HELPERS

			    // LOCALES

			    function localeWeek(mom) {
			        return weekOfYear(mom, this._week.dow, this._week.doy).week;
			    }

			    var defaultLocaleWeek = {
			        dow: 0, // Sunday is the first day of the week.
			        doy: 6, // The week that contains Jan 6th is the first week of the year.
			    };

			    function localeFirstDayOfWeek() {
			        return this._week.dow;
			    }

			    function localeFirstDayOfYear() {
			        return this._week.doy;
			    }

			    // MOMENTS

			    function getSetWeek(input) {
			        var week = this.localeData().week(this);
			        return input == null ? week : this.add((input - week) * 7, 'd');
			    }

			    function getSetISOWeek(input) {
			        var week = weekOfYear(this, 1, 4).week;
			        return input == null ? week : this.add((input - week) * 7, 'd');
			    }

			    // FORMATTING

			    addFormatToken('d', 0, 'do', 'day');

			    addFormatToken('dd', 0, 0, function (format) {
			        return this.localeData().weekdaysMin(this, format);
			    });

			    addFormatToken('ddd', 0, 0, function (format) {
			        return this.localeData().weekdaysShort(this, format);
			    });

			    addFormatToken('dddd', 0, 0, function (format) {
			        return this.localeData().weekdays(this, format);
			    });

			    addFormatToken('e', 0, 0, 'weekday');
			    addFormatToken('E', 0, 0, 'isoWeekday');

			    // ALIASES

			    addUnitAlias('day', 'd');
			    addUnitAlias('weekday', 'e');
			    addUnitAlias('isoWeekday', 'E');

			    // PRIORITY
			    addUnitPriority('day', 11);
			    addUnitPriority('weekday', 11);
			    addUnitPriority('isoWeekday', 11);

			    // PARSING

			    addRegexToken('d', match1to2);
			    addRegexToken('e', match1to2);
			    addRegexToken('E', match1to2);
			    addRegexToken('dd', function (isStrict, locale) {
			        return locale.weekdaysMinRegex(isStrict);
			    });
			    addRegexToken('ddd', function (isStrict, locale) {
			        return locale.weekdaysShortRegex(isStrict);
			    });
			    addRegexToken('dddd', function (isStrict, locale) {
			        return locale.weekdaysRegex(isStrict);
			    });

			    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
			        var weekday = config._locale.weekdaysParse(input, token, config._strict);
			        // if we didn't get a weekday name, mark the date as invalid
			        if (weekday != null) {
			            week.d = weekday;
			        } else {
			            getParsingFlags(config).invalidWeekday = input;
			        }
			    });

			    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
			        week[token] = toInt(input);
			    });

			    // HELPERS

			    function parseWeekday(input, locale) {
			        if (typeof input !== 'string') {
			            return input;
			        }

			        if (!isNaN(input)) {
			            return parseInt(input, 10);
			        }

			        input = locale.weekdaysParse(input);
			        if (typeof input === 'number') {
			            return input;
			        }

			        return null;
			    }

			    function parseIsoWeekday(input, locale) {
			        if (typeof input === 'string') {
			            return locale.weekdaysParse(input) % 7 || 7;
			        }
			        return isNaN(input) ? null : input;
			    }

			    // LOCALES
			    function shiftWeekdays(ws, n) {
			        return ws.slice(n, 7).concat(ws.slice(0, n));
			    }

			    var defaultLocaleWeekdays =
			            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
			        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
			        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
			        defaultWeekdaysRegex = matchWord,
			        defaultWeekdaysShortRegex = matchWord,
			        defaultWeekdaysMinRegex = matchWord;

			    function localeWeekdays(m, format) {
			        var weekdays = isArray(this._weekdays)
			            ? this._weekdays
			            : this._weekdays[
			                  m && m !== true && this._weekdays.isFormat.test(format)
			                      ? 'format'
			                      : 'standalone'
			              ];
			        return m === true
			            ? shiftWeekdays(weekdays, this._week.dow)
			            : m
			            ? weekdays[m.day()]
			            : weekdays;
			    }

			    function localeWeekdaysShort(m) {
			        return m === true
			            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
			            : m
			            ? this._weekdaysShort[m.day()]
			            : this._weekdaysShort;
			    }

			    function localeWeekdaysMin(m) {
			        return m === true
			            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
			            : m
			            ? this._weekdaysMin[m.day()]
			            : this._weekdaysMin;
			    }

			    function handleStrictParse$1(weekdayName, format, strict) {
			        var i,
			            ii,
			            mom,
			            llc = weekdayName.toLocaleLowerCase();
			        if (!this._weekdaysParse) {
			            this._weekdaysParse = [];
			            this._shortWeekdaysParse = [];
			            this._minWeekdaysParse = [];

			            for (i = 0; i < 7; ++i) {
			                mom = createUTC([2000, 1]).day(i);
			                this._minWeekdaysParse[i] = this.weekdaysMin(
			                    mom,
			                    ''
			                ).toLocaleLowerCase();
			                this._shortWeekdaysParse[i] = this.weekdaysShort(
			                    mom,
			                    ''
			                ).toLocaleLowerCase();
			                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
			            }
			        }

			        if (strict) {
			            if (format === 'dddd') {
			                ii = indexOf.call(this._weekdaysParse, llc);
			                return ii !== -1 ? ii : null;
			            } else if (format === 'ddd') {
			                ii = indexOf.call(this._shortWeekdaysParse, llc);
			                return ii !== -1 ? ii : null;
			            } else {
			                ii = indexOf.call(this._minWeekdaysParse, llc);
			                return ii !== -1 ? ii : null;
			            }
			        } else {
			            if (format === 'dddd') {
			                ii = indexOf.call(this._weekdaysParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._shortWeekdaysParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._minWeekdaysParse, llc);
			                return ii !== -1 ? ii : null;
			            } else if (format === 'ddd') {
			                ii = indexOf.call(this._shortWeekdaysParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._weekdaysParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._minWeekdaysParse, llc);
			                return ii !== -1 ? ii : null;
			            } else {
			                ii = indexOf.call(this._minWeekdaysParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._weekdaysParse, llc);
			                if (ii !== -1) {
			                    return ii;
			                }
			                ii = indexOf.call(this._shortWeekdaysParse, llc);
			                return ii !== -1 ? ii : null;
			            }
			        }
			    }

			    function localeWeekdaysParse(weekdayName, format, strict) {
			        var i, mom, regex;

			        if (this._weekdaysParseExact) {
			            return handleStrictParse$1.call(this, weekdayName, format, strict);
			        }

			        if (!this._weekdaysParse) {
			            this._weekdaysParse = [];
			            this._minWeekdaysParse = [];
			            this._shortWeekdaysParse = [];
			            this._fullWeekdaysParse = [];
			        }

			        for (i = 0; i < 7; i++) {
			            // make the regex if we don't have it already

			            mom = createUTC([2000, 1]).day(i);
			            if (strict && !this._fullWeekdaysParse[i]) {
			                this._fullWeekdaysParse[i] = new RegExp(
			                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
			                    'i'
			                );
			                this._shortWeekdaysParse[i] = new RegExp(
			                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
			                    'i'
			                );
			                this._minWeekdaysParse[i] = new RegExp(
			                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
			                    'i'
			                );
			            }
			            if (!this._weekdaysParse[i]) {
			                regex =
			                    '^' +
			                    this.weekdays(mom, '') +
			                    '|^' +
			                    this.weekdaysShort(mom, '') +
			                    '|^' +
			                    this.weekdaysMin(mom, '');
			                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
			            }
			            // test the regex
			            if (
			                strict &&
			                format === 'dddd' &&
			                this._fullWeekdaysParse[i].test(weekdayName)
			            ) {
			                return i;
			            } else if (
			                strict &&
			                format === 'ddd' &&
			                this._shortWeekdaysParse[i].test(weekdayName)
			            ) {
			                return i;
			            } else if (
			                strict &&
			                format === 'dd' &&
			                this._minWeekdaysParse[i].test(weekdayName)
			            ) {
			                return i;
			            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
			                return i;
			            }
			        }
			    }

			    // MOMENTS

			    function getSetDayOfWeek(input) {
			        if (!this.isValid()) {
			            return input != null ? this : NaN;
			        }
			        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
			        if (input != null) {
			            input = parseWeekday(input, this.localeData());
			            return this.add(input - day, 'd');
			        } else {
			            return day;
			        }
			    }

			    function getSetLocaleDayOfWeek(input) {
			        if (!this.isValid()) {
			            return input != null ? this : NaN;
			        }
			        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
			        return input == null ? weekday : this.add(input - weekday, 'd');
			    }

			    function getSetISODayOfWeek(input) {
			        if (!this.isValid()) {
			            return input != null ? this : NaN;
			        }

			        // behaves the same as moment#day except
			        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
			        // as a setter, sunday should belong to the previous week.

			        if (input != null) {
			            var weekday = parseIsoWeekday(input, this.localeData());
			            return this.day(this.day() % 7 ? weekday : weekday - 7);
			        } else {
			            return this.day() || 7;
			        }
			    }

			    function weekdaysRegex(isStrict) {
			        if (this._weekdaysParseExact) {
			            if (!hasOwnProp(this, '_weekdaysRegex')) {
			                computeWeekdaysParse.call(this);
			            }
			            if (isStrict) {
			                return this._weekdaysStrictRegex;
			            } else {
			                return this._weekdaysRegex;
			            }
			        } else {
			            if (!hasOwnProp(this, '_weekdaysRegex')) {
			                this._weekdaysRegex = defaultWeekdaysRegex;
			            }
			            return this._weekdaysStrictRegex && isStrict
			                ? this._weekdaysStrictRegex
			                : this._weekdaysRegex;
			        }
			    }

			    function weekdaysShortRegex(isStrict) {
			        if (this._weekdaysParseExact) {
			            if (!hasOwnProp(this, '_weekdaysRegex')) {
			                computeWeekdaysParse.call(this);
			            }
			            if (isStrict) {
			                return this._weekdaysShortStrictRegex;
			            } else {
			                return this._weekdaysShortRegex;
			            }
			        } else {
			            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
			                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
			            }
			            return this._weekdaysShortStrictRegex && isStrict
			                ? this._weekdaysShortStrictRegex
			                : this._weekdaysShortRegex;
			        }
			    }

			    function weekdaysMinRegex(isStrict) {
			        if (this._weekdaysParseExact) {
			            if (!hasOwnProp(this, '_weekdaysRegex')) {
			                computeWeekdaysParse.call(this);
			            }
			            if (isStrict) {
			                return this._weekdaysMinStrictRegex;
			            } else {
			                return this._weekdaysMinRegex;
			            }
			        } else {
			            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
			                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
			            }
			            return this._weekdaysMinStrictRegex && isStrict
			                ? this._weekdaysMinStrictRegex
			                : this._weekdaysMinRegex;
			        }
			    }

			    function computeWeekdaysParse() {
			        function cmpLenRev(a, b) {
			            return b.length - a.length;
			        }

			        var minPieces = [],
			            shortPieces = [],
			            longPieces = [],
			            mixedPieces = [],
			            i,
			            mom,
			            minp,
			            shortp,
			            longp;
			        for (i = 0; i < 7; i++) {
			            // make the regex if we don't have it already
			            mom = createUTC([2000, 1]).day(i);
			            minp = regexEscape(this.weekdaysMin(mom, ''));
			            shortp = regexEscape(this.weekdaysShort(mom, ''));
			            longp = regexEscape(this.weekdays(mom, ''));
			            minPieces.push(minp);
			            shortPieces.push(shortp);
			            longPieces.push(longp);
			            mixedPieces.push(minp);
			            mixedPieces.push(shortp);
			            mixedPieces.push(longp);
			        }
			        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
			        // will match the longer piece.
			        minPieces.sort(cmpLenRev);
			        shortPieces.sort(cmpLenRev);
			        longPieces.sort(cmpLenRev);
			        mixedPieces.sort(cmpLenRev);

			        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
			        this._weekdaysShortRegex = this._weekdaysRegex;
			        this._weekdaysMinRegex = this._weekdaysRegex;

			        this._weekdaysStrictRegex = new RegExp(
			            '^(' + longPieces.join('|') + ')',
			            'i'
			        );
			        this._weekdaysShortStrictRegex = new RegExp(
			            '^(' + shortPieces.join('|') + ')',
			            'i'
			        );
			        this._weekdaysMinStrictRegex = new RegExp(
			            '^(' + minPieces.join('|') + ')',
			            'i'
			        );
			    }

			    // FORMATTING

			    function hFormat() {
			        return this.hours() % 12 || 12;
			    }

			    function kFormat() {
			        return this.hours() || 24;
			    }

			    addFormatToken('H', ['HH', 2], 0, 'hour');
			    addFormatToken('h', ['hh', 2], 0, hFormat);
			    addFormatToken('k', ['kk', 2], 0, kFormat);

			    addFormatToken('hmm', 0, 0, function () {
			        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
			    });

			    addFormatToken('hmmss', 0, 0, function () {
			        return (
			            '' +
			            hFormat.apply(this) +
			            zeroFill(this.minutes(), 2) +
			            zeroFill(this.seconds(), 2)
			        );
			    });

			    addFormatToken('Hmm', 0, 0, function () {
			        return '' + this.hours() + zeroFill(this.minutes(), 2);
			    });

			    addFormatToken('Hmmss', 0, 0, function () {
			        return (
			            '' +
			            this.hours() +
			            zeroFill(this.minutes(), 2) +
			            zeroFill(this.seconds(), 2)
			        );
			    });

			    function meridiem(token, lowercase) {
			        addFormatToken(token, 0, 0, function () {
			            return this.localeData().meridiem(
			                this.hours(),
			                this.minutes(),
			                lowercase
			            );
			        });
			    }

			    meridiem('a', true);
			    meridiem('A', false);

			    // ALIASES

			    addUnitAlias('hour', 'h');

			    // PRIORITY
			    addUnitPriority('hour', 13);

			    // PARSING

			    function matchMeridiem(isStrict, locale) {
			        return locale._meridiemParse;
			    }

			    addRegexToken('a', matchMeridiem);
			    addRegexToken('A', matchMeridiem);
			    addRegexToken('H', match1to2);
			    addRegexToken('h', match1to2);
			    addRegexToken('k', match1to2);
			    addRegexToken('HH', match1to2, match2);
			    addRegexToken('hh', match1to2, match2);
			    addRegexToken('kk', match1to2, match2);

			    addRegexToken('hmm', match3to4);
			    addRegexToken('hmmss', match5to6);
			    addRegexToken('Hmm', match3to4);
			    addRegexToken('Hmmss', match5to6);

			    addParseToken(['H', 'HH'], HOUR);
			    addParseToken(['k', 'kk'], function (input, array, config) {
			        var kInput = toInt(input);
			        array[HOUR] = kInput === 24 ? 0 : kInput;
			    });
			    addParseToken(['a', 'A'], function (input, array, config) {
			        config._isPm = config._locale.isPM(input);
			        config._meridiem = input;
			    });
			    addParseToken(['h', 'hh'], function (input, array, config) {
			        array[HOUR] = toInt(input);
			        getParsingFlags(config).bigHour = true;
			    });
			    addParseToken('hmm', function (input, array, config) {
			        var pos = input.length - 2;
			        array[HOUR] = toInt(input.substr(0, pos));
			        array[MINUTE] = toInt(input.substr(pos));
			        getParsingFlags(config).bigHour = true;
			    });
			    addParseToken('hmmss', function (input, array, config) {
			        var pos1 = input.length - 4,
			            pos2 = input.length - 2;
			        array[HOUR] = toInt(input.substr(0, pos1));
			        array[MINUTE] = toInt(input.substr(pos1, 2));
			        array[SECOND] = toInt(input.substr(pos2));
			        getParsingFlags(config).bigHour = true;
			    });
			    addParseToken('Hmm', function (input, array, config) {
			        var pos = input.length - 2;
			        array[HOUR] = toInt(input.substr(0, pos));
			        array[MINUTE] = toInt(input.substr(pos));
			    });
			    addParseToken('Hmmss', function (input, array, config) {
			        var pos1 = input.length - 4,
			            pos2 = input.length - 2;
			        array[HOUR] = toInt(input.substr(0, pos1));
			        array[MINUTE] = toInt(input.substr(pos1, 2));
			        array[SECOND] = toInt(input.substr(pos2));
			    });

			    // LOCALES

			    function localeIsPM(input) {
			        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
			        // Using charAt should be more compatible.
			        return (input + '').toLowerCase().charAt(0) === 'p';
			    }

			    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
			        // Setting the hour should keep the time, because the user explicitly
			        // specified which hour they want. So trying to maintain the same hour (in
			        // a new timezone) makes sense. Adding/subtracting hours does not follow
			        // this rule.
			        getSetHour = makeGetSet('Hours', true);

			    function localeMeridiem(hours, minutes, isLower) {
			        if (hours > 11) {
			            return isLower ? 'pm' : 'PM';
			        } else {
			            return isLower ? 'am' : 'AM';
			        }
			    }

			    var baseConfig = {
			        calendar: defaultCalendar,
			        longDateFormat: defaultLongDateFormat,
			        invalidDate: defaultInvalidDate,
			        ordinal: defaultOrdinal,
			        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
			        relativeTime: defaultRelativeTime,

			        months: defaultLocaleMonths,
			        monthsShort: defaultLocaleMonthsShort,

			        week: defaultLocaleWeek,

			        weekdays: defaultLocaleWeekdays,
			        weekdaysMin: defaultLocaleWeekdaysMin,
			        weekdaysShort: defaultLocaleWeekdaysShort,

			        meridiemParse: defaultLocaleMeridiemParse,
			    };

			    // internal storage for locale config files
			    var locales = {},
			        localeFamilies = {},
			        globalLocale;

			    function commonPrefix(arr1, arr2) {
			        var i,
			            minl = Math.min(arr1.length, arr2.length);
			        for (i = 0; i < minl; i += 1) {
			            if (arr1[i] !== arr2[i]) {
			                return i;
			            }
			        }
			        return minl;
			    }

			    function normalizeLocale(key) {
			        return key ? key.toLowerCase().replace('_', '-') : key;
			    }

			    // pick the locale from the array
			    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
			    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
			    function chooseLocale(names) {
			        var i = 0,
			            j,
			            next,
			            locale,
			            split;

			        while (i < names.length) {
			            split = normalizeLocale(names[i]).split('-');
			            j = split.length;
			            next = normalizeLocale(names[i + 1]);
			            next = next ? next.split('-') : null;
			            while (j > 0) {
			                locale = loadLocale(split.slice(0, j).join('-'));
			                if (locale) {
			                    return locale;
			                }
			                if (
			                    next &&
			                    next.length >= j &&
			                    commonPrefix(split, next) >= j - 1
			                ) {
			                    //the next array item is better than a shallower substring of this one
			                    break;
			                }
			                j--;
			            }
			            i++;
			        }
			        return globalLocale;
			    }

			    function isLocaleNameSane(name) {
			        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
			        return name.match('^[^/\\\\]*$') != null;
			    }

			    function loadLocale(name) {
			        var oldLocale = null,
			            aliasedRequire;
			        // TODO: Find a better way to register and load all the locales in Node
			        if (
			            locales[name] === undefined &&
			            'object' !== 'undefined' &&
			            module &&
			            module.exports &&
			            isLocaleNameSane(name)
			        ) {
			            try {
			                oldLocale = globalLocale._abbr;
			                aliasedRequire = commonjsRequire;
			                aliasedRequire('./locale/' + name);
			                getSetGlobalLocale(oldLocale);
			            } catch (e) {
			                // mark as not found to avoid repeating expensive file require call causing high CPU
			                // when trying to find en-US, en_US, en-us for every format call
			                locales[name] = null; // null means not found
			            }
			        }
			        return locales[name];
			    }

			    // This function will load locale and then set the global locale.  If
			    // no arguments are passed in, it will simply return the current global
			    // locale key.
			    function getSetGlobalLocale(key, values) {
			        var data;
			        if (key) {
			            if (isUndefined(values)) {
			                data = getLocale(key);
			            } else {
			                data = defineLocale(key, values);
			            }

			            if (data) {
			                // moment.duration._locale = moment._locale = data;
			                globalLocale = data;
			            } else {
			                if (typeof console !== 'undefined' && console.warn) {
			                    //warn user if arguments are passed but the locale could not be set
			                    console.warn(
			                        'Locale ' + key + ' not found. Did you forget to load it?'
			                    );
			                }
			            }
			        }

			        return globalLocale._abbr;
			    }

			    function defineLocale(name, config) {
			        if (config !== null) {
			            var locale,
			                parentConfig = baseConfig;
			            config.abbr = name;
			            if (locales[name] != null) {
			                deprecateSimple(
			                    'defineLocaleOverride',
			                    'use moment.updateLocale(localeName, config) to change ' +
			                        'an existing locale. moment.defineLocale(localeName, ' +
			                        'config) should only be used for creating a new locale ' +
			                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
			                );
			                parentConfig = locales[name]._config;
			            } else if (config.parentLocale != null) {
			                if (locales[config.parentLocale] != null) {
			                    parentConfig = locales[config.parentLocale]._config;
			                } else {
			                    locale = loadLocale(config.parentLocale);
			                    if (locale != null) {
			                        parentConfig = locale._config;
			                    } else {
			                        if (!localeFamilies[config.parentLocale]) {
			                            localeFamilies[config.parentLocale] = [];
			                        }
			                        localeFamilies[config.parentLocale].push({
			                            name: name,
			                            config: config,
			                        });
			                        return null;
			              